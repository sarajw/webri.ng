import { logger } from '../';
import { invalidExistingPasswordError, userNotFoundError } from '../../api/api-error-response';
import { User, UUID } from '../../model';
import { InvalidUserCredentialsError, UserNotFoundError } from '../error';
import { getUser, GetUserSearchField } from '.';
import { hashPassword, validatePassword } from './password';
import { appDataSource } from '../../infra/database';

/**
 * Updates an existing user's password.
 * @warning Errors generated by the username and password validation functions will be
 * propagated upwards to the caller.
 * @async
 * @param {UUID} userId The id of the user to update the password for.
 * @param {string} newPassword The user's new password.
 * @returns The updated user entity.
 */
export async function updatePassword(userId: UUID,
	existingPassword: string,
	newPassword: string): Promise<User>
{
	const user = await getUser(GetUserSearchField.UserId, userId);
	if (!user) {
		throw new UserNotFoundError(`User with id '${userId}' cannot be found`,
			userNotFoundError.code, userNotFoundError.httpStatus);
	}

	// Validate the user's existing password.
	const passwordValidity = await validatePassword(existingPassword, user.passwordHash);
	if (!passwordValidity) {
		throw new InvalidUserCredentialsError(invalidExistingPasswordError.message,
			invalidExistingPasswordError.code, invalidExistingPasswordError.httpStatus);
	}

	// Validate the new password. Raises an exception on validation failure.
	User.validateNewPassword(newPassword);

	// Hash the new password, and store in the user entity.
	user.passwordHash = await hashPassword(newPassword);
	user.dateModified = new Date();
	user.passwordSetTime = new Date();
	user.passwordExpiryTime = User.getPasswordExpiryDate();

	logger.info(`Updating password for user: '${userId}'`);

	return appDataSource.getRepository(User).save(user);
}
